[TOC]

# 在线文章阅读器

## 前言

欢迎来到我们的在线文章阅读器项目！本项目将引导同学们编写一个带搜索功能的在线文章阅读器，采用"客户端/服务器"（C/S）架构。我们希望让同学们在通过编写客户端和服务器的程序中，感受python模块化编程的思想，了解网络通信的基本原理，在实现实现查询和检索算法的同时，熟悉并运用正则表达式。同时，对于学有余力的同学，我们还提供了一些附加任务，例如编写交互界面，文件上传和下载、多线程服务器等，供同学们挑战。

## 项目概述

在本项目中，我们将编写一个在线文章阅读器。其分为客户端和服务器两个部分，客户端负责向服务器发送查询请求，服务器负责解析查询请求，检索文章内容，并将检索结果返回给客户端。客户端接收服务器返回的检索结果，并在界面上显示搜索得到的文章列表与内容。

> 客户端/服务器（C/S）架构是一种分布式应用程序的设计模式。在这种架构中，客户端是请求数据的设备，服务器是提供数据的设备。客户端和服务器之间通过网络进行通信，客户端向服务器发送请求，服务器处理请求并返回结果。

在本次项目中，我们将编写两个程序，分别是客户端和服务器，我们将同时运行这两个程序，通过网络通信实现数据的传输。


### 项目评分
本项目评分满分为100分。完成基础的部分同学们即可获得90分，我们还提供了一些附加任务，需要同学们选择性的去完成一些。
- **基础框架（20+分）**：客户端和服务器的框架基本完成。
- **网络通信（20分）**：客户端和服务器能够正确建立连接并进行数据传输。这部分按照我们给出的代码编写，能够正常进行“握手”通信即可。
- **查询搜索（20分）**：客户端能够发送查询请求，服务器能够解析查询文字并进行检索。
- **文章管理与内容返回（30+分）**：服务器能够管理现有的所有文章，接收客户端的检索请求，将检索结果返回给客户端，并在客户端显示。
- **附加功能**：
    - **交互界面（10分）**：客户端能够使用图形用户界面进行交互。
    - **文件上传和下载（5分）**：客户端能够上传文章（文本文件）到服务器，服务器能够接收文件并保存，客户端能够下载服务器上的文章。
    - **多线程服务器（5分）**：服务器能够同时处理多个客户端的请求。
    - **隐含语义挖掘（10分）**：除了搜索检索词外，我们还可以设计一些自然语言处理的算法来挖掘文章的隐含语义，提高搜索的准确性。例如，对于用户输入的“攀岩”，我们可以返回与攀岩相关的文章，例如“登山”、“户外运动”等。同学们会在这一部分了解到自然语言处理的一些基础知识，例如*词向量*等。

## 下发文件

我们将提供以下文件：

- `client.py`：客户端程序模板。
- `server.py`：服务器程序模板。
- `socket_client.py`：一个简单的客户端程序，用于示范客户连接（握手）与通信。
- `socket_server.py`：一个简单的服务器程序，用于示范服务器连接（握手）与通信。
- `network.py`：建议同学们自定义的一个网络通信包，放置你编写的一些基本函数。
- `articles/*.txt`：为同学们提供的一些文章文本文件，供同学们使用。
- `README.pdf`：项目说明文件。

## 提交文件

请将以下文件打包为一个压缩包，命名为`学号_姓名.zip`，其中`学号`为你的学号，`姓名`为你的姓名。请将以下文件放入压缩包中：

- `client.py`：您实现的客户端程序。
- `server.py`：您实现的服务器程序。
- 您的项目报告文件，包括项目概述、实现细节、使用说明等。
- 其他您认为有必要提交的文件，例如演示视频等。

## 任务内容

### 任务0：客户端与服务器的基本框架（20+分）

在开始编写客户端和服务器之前，我们先来梳理一下客户端和服务器的基本任务：

客户端必须要实现以下功能：
1. 与服务器建立连接。
2. 接收用户输入的查询请求。
3. 向服务器发送查询请求。
4. 接收服务器返回的可能文章及内容。
5. 将结果展示给用户。
6. 用户选择想要浏览的文章。
7. 将文章内容展示给用户。

而服务器必须要实现以下功能：
1. 初始化，管理文章内容。
2. 等待客户端的连接。
3. 接收客户端发送的查询请求。
4. 解析查询请求，检索文章。
5. 将匹配到的文章内容返回给客户端。

> 当然你也可以这样子设计客户端：
> 1. 与服务器建立连接。
> 2. 接收用户输入的查询请求。
> 3. 向服务器发送查询请求。
> 4. 接收服务器返回的文章**信息**。
> 5. 将结果展示给用户。
> 6. 用户选择想要浏览的文章。
> 7. 向服务器发送请求获取文章内容。
> 8. 接收服务器返回的文章内容。
> 9. 将文章内容展示给用户。
>
> 而相应的服务器需要实现以下功能：
> 1. 初始化，管理文章内容。
> 2. 等待客户端的连接。
> 3. 接收客户端发送的查询请求。
> 4. 解析查询请求，检索文章。
> 5. 将匹配到的文章信息返回给客户端。
> 6. 接收客户端发送的文章请求。
> 7. 将文章内容返回给客户端。
>
> 这样的设计可以减少不必要的数据传输，提高程序的效率。当然，你也可以根据自己的设计来实现客户端和服务器的功能，这部分请在报告中说明。
> 
> 对于这样的设计，我们会给予一定的加分。


关于不同的程序间如何建立连接，不用着急，我们将在下一部分中介绍。
我们现在先假设connection已经建立，且我们可以简单的用`send_str`和`recv_str`来进行字符串的传输。

一个粗略的客户端和服务器的框架已经在`client.py`和`server.py`中给出。同学们可以量力而行，根据自己的设计来修改这个框架。

#### 评分标准

代码功能与报告描述基本一致即可。

### 任务一：网络通信（20分）

在本任务中，我们将实现客户端和服务器之间从建立连接到网络通信的过程。同学们会在这部分了解到网络通信的基本单位——**报文**，并使用Python的`socket`库来实现客户端和服务器之间的通信。

> tips: 以下的内容是网络通信的基础知识，虽然内容很长，但是同学们只需要走马观花了解基本的概念即可，不需要深入了解底层原理。**关键代码都在模板和文档中给出**，同学们将代码整合到上一部分的代码即可。

> 有网络通信基础的同学可以跳过这一部分，直接开始第二部分内容的编写。

#### socket通信基础

Socket通信是网络编程中最基础的通信方式之一。它允许两个进程之间通过网络进行数据交换。以下是Socket通信从**建立连接**到**数据传输**的基本过程：

1. **创建Socket**：在客户端和服务器端都需要创建一个Socket对象。服务器端的Socket用于监听客户端的连接请求，客户端的Socket用于向服务器发起连接请求。
2. **绑定地址和端口（bind）**：服务器端需要将Socket绑定到一个特定的地址和端口，以便客户端能够找到并连接到服务器。
3. **监听连接（listen）**：服务器端的Socket需要进入监听状态，等待客户端的连接请求。
4. **接受连接（accept）**：当客户端发起连接请求时，服务器端的Socket会接受连接，并返回一个新的Socket对象，用于与客户端进行通信。
5. **建立连接（connect）**：客户端的Socket向服务器发起连接请求，服务器接受连接后，客户端和服务器之间的连接就建立起来了。
6. **数据传输**：客户端和服务器可以通过各自的Socket对象发送和接收数据。
7. **关闭连接**：数据传输完成后，客户端和服务器需要关闭各自的Socket，以释放资源。

> 同学们不必深入了解Socket通信的底层原理，只需要掌握如何使用Python的`socket`库来实现进程间的通信即可。

我们将使用Python的`socket`库来实现网络通信。`socket`库提供了一些基本的网络通信功能，例如创建套接字、建立连接、发送数据等。

Python的`socket`库提供了以下主要接口来实现上述过程：

- `socket(family, type)`：创建一个新的Socket对象，用于网络通信。在本次项目中，客户端和服务器端都需要创建一个Socket对象，即
`new_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)`。
- `Socket.bind(address)`：服务器端Socket对象的方法，将该对象绑定到指定的地址和端口。项目中由于是本地的两个程序进行通信，所以使用`localhost`作为地址（即`127.0.0.1`），端口号可以任意指定。
- `Socket.listen(backlog)`：使绑定好的Socket进入活跃的监听状态，等待客户端的连接请求。`backlog`参数指定连接队列的最大长度，设置一个较小的值即可。
- `Socket.accept()`：服务器端Socket接受客户端的连接请求，返回一个新的Socket对象和客户端的地址信息。
- `Socket.connect(address)`：客户端Socket向服务器发起连接请求。`address`是服务器的地址和端口号。
- `Socket.send(data)`：通过Socket发送*二进制数据*。`data`是要发送的字节序列，如果要发送字符串，需要使用`encode`方法将字符串转换为字节序列。
- `Socket.recv(bufsize)`：通过Socket接收*二进制数据*。`bufsize`参数指定一次接收的最大字节数。同理，如果接收到的是字节序列，需要使用`decode`方法将字节序列转换为字符串。
- `Socket.close()`：关闭Socket，释放资源。

服务器和客户端使用以上接口，从监听到建立连接的过程，我们称之为“握手”。在双方“握手”完成之后，便可以使用`send`和`recv`方法来进行数据的发送和接收。

其中服务器端和客户端的握手代码我们已经给出（详见`socket_server.py`和`socket_client.py`），同学们可以直接挪用到自己的代码中。

我们关注`send`和`recv`方法来实现数据的发送和接收。这两个方法将二进制数据发送到对方，并接收对方发送的二进制数据。在实际应用中，我们可以将字符串转换为二进制数据，然后通过`send`方法发送，接收到的二进制数据再转换为字符串。

注意在发送和接收长数据时，最好使用循环来处理。下面是一个例子：

```python
# 发送一定长度的二进制数据
def send_long_data(sock, data):
    total_sent = 0
    while total_sent < len(data):
        # 一次发送的数据不会超过接收方的缓冲区大小
        # 同时由于网络的不确定性，可能需要多次发送
        # 所以需要循环发送，直到所有数据都发送完毕
        sent = sock.send(data[total_sent:]) # sent是实际发送的字节数
        if sent == 0:
            raise RuntimeError("Socket connection broken")
        total_sent += sent
```

```python
# 接收一定长度的二进制数据
def recv_long_data(sock, length):
    data = b''
    while len(data) < length:
        chunk = sock.recv(length - len(data))
        if chunk == b'':
            raise RuntimeError("Socket connection broken")
        data += chunk
    return data
```

#### “报头”：报文的格式规范

有些同学可能已经发现了：在接收方接受binary数据时，我们需要先了解数据的长度，然后才能正确接受数据。但该怎么向对方发送数据的长度呢？这就需要我们定义一个固定长度的串，放在需要发送的数据前面，告诉对方接下来要发送的数据的长度。这个串就是 **“报头”**。“报头”和后面的数据加在一起，我们称之为 **“报文”**。

我们可以定义一个简单的报头格式，例如在数据串前面加上一个4字节的整数，表示数据的长度。

| 4Bytes         | length Bytes |
| -------------- | ------------ |
| 数据长度length | binary data  |


发送方可以先发送报头，然后发送数据：

```python
# 发送数据
def send_str(sock, str):
    length = len(data)
    # 将数据长度转换为4字节的二进制数据
    header = length.to_bytes(4, 'big') # 将数据转换为适合网络传输的big-endian
    # 发送报头
    send_long_data(sock, header)
    # 发送数据
    send_long_data(sock, str.encode())
```
那么我们的接收方就可以先接收4字节的数据，然后根据这个长度接收后面的数据。

```python
# 接收数据
def recv_str(sock):
    # 接收报头
    header = recv_long_str(sock, 4)
    length = int.from_bytes(header, 'big')
    # 接收数据
    data = recv_long_data(sock, length)
    return data
```

当然，你也可以定义更复杂的报头格式，例如在报头中加入数据类型、数据校验等信息。若你实现了这些完整的报头功能，可以在报告中说明，我们会给予一定的加分。

> 以上代码你都可以写在`network.py`中，然后在`client.py`和`server.py`中引用。

#### 评分标准

完成客户端和服务器的代码之后，二者能够正确建立连接并进行数据传输。这部分按照我们给出的代码编写，程序之间能够正常握手即可。

### 任务二：客户端功能实现、查询搜索（20分）

有了以上的基础，我们就可以开始实现客户端和服务器的功能了。

我们将客户端的功能分为两部分：查询搜索和文章展示。

#### 查询搜索

这一部分，客户端需要接收用户输入的查询请求，将查询请求发送给服务器，接收服务器返回的检索结果。
服务器返回的结果由你来设计，比如一个包含文章标题和匹配度的列表，客户端需要将这些结果展示给用户。

#### 文章展示

在文章展示部分，客户端需要将检索结果展示给用户。
用户可以选择想要查看的文章，实现方式可以是用户输入文章的编号，也可以是用户点击文章标题等等。在用户选择文章之后，客户端需要能够将选择文章内容展示给用户。

#### 评分标准

提交上来的代码，助教能正常运行，必需的功能完备，且能得到结果（不一定合理也可）

### 任务三：文章管理与内容返回（30+分）

服务器相对于客户端，需要实现的功能更多。在这一部分，我们将实现服务器的文章管理，文章查询功能。

#### 文章管理（10分）

在服务器与客户端交互之前，服务器需要先加载文章内容。我们会提供一些文章文本文件，同学们也可以自由添加其他的文件。服务器需要提前读取这些文件，并将文章内容存储在内存中。

如果想满足查询的需求，我们可以将文章内容存储在一个字典中，字典的键是文章的标题，值是文章的内容。
或者我们可以给每一篇文章一个编号，将文章的编号、标题和内容存储在一个列表中。

当然，你也可以使用其他的数据结构来存储文章内容，只要能够满足查询的需求即可。

同学们可以使用以下代码来读取`articles`文件夹下的所有txt文件，并存储在一个词典中：
```python 
import os # 用于文件操作

# 读取articles文件夹下，所有txt文件的内容，存储在一个字典中
def read_articles():
    articles = {}
    for file in os.listdir('articles'):
        if file.endswith('.txt'):
            with open(os.path.join('articles', file), 'r', encoding='utf-8') as f:
                title = file.split('.')[0]
                content = f.read()
                articles[title] = content # 这个存储方式可以根据自己的需求来修改
    return articles
```

#### 文章查询与发送（20分）

服务器需要接收客户端发送的查询请求，解析查询请求，检索文章内容，并将检索结果返回给客户端。

这里给同学们提供一个可供参考的检索方式，你也可以根据自己的需求来设计检索算法。

我们可以使用`jieba`库的`cut`等方法来对中文文章内容进行分词，然后计算查询词与文章内容的匹配程度。`jieba`即结巴分词，是一个中文分词工具，可以将中文文本便捷分割成一个个词语。

一个使用例：
```python
import jieba
example_text = "我爱北京大学"
words = jieba.lcut_for_search(example_text) # 返回一个列表，分词后的结果
```

> 关于jieba的更多打开方式，例如定义停用词表从而删除符号和语气词等，同学们可以自行上网搜索。（很简单）

得到分词的结果之后，我们可以计算查询词与文章内容的匹配程度。一种简单的方法是计算查询词在文章内容中出现的次数，出现次数越多，匹配程度越高。你可以使用字符串的find方法，或者正则表达式来轻松实现这个功能。

> **附加任务：高级查询功能**（+5分）
> 
> 除了可以简单搜索文本之外，我们可以选择为用户提供关键词以及逻辑查询的高级选项。市面上的搜索引擎例如Google、百度等都提供这样的功能：用户可以通过输入一些特定的关键词与逻辑谓词来限定搜索范围。
> 
> 同学们可以尝试设计一些高级查询功能，例如+keyword表示必须包含该关键词，-keyword表示不包含该关键词，AND、OR、NOT等逻辑运算符等。完成该任务的同学可以获得额外的加分。

当然，同学们也可以使用其他的方法来实现查询功能，只要能够满足查询的需求即可。我们在附加任务中还提供了另一种基于自然语言处理的搜索方式，感兴趣的同学们可以尝试实现。

#### 返回查询结果

在得到查询结果之后，服务器需要将查询结果返回给客户端。同学们可以把内容按特定格式拼接成一个字符串，然后通过`send_str`方法发送给客户端，由客户端来解析这个字符串。
> 感兴趣的同学还可以使用`pickle`库将查询结果二进制序列化，然后发送给客户端，再由客户端转回为字典。

#### 评分标准

服务器端可以正常与客户端的请求交互，能够正确解析查询请求，检索出相对正确的文章内容，并将检索结果返回给客户端即可。

### 附加任务

#### 交互界面（10分）

我们当然可以通过命令行来运行我们的客户端和服务器程序，就像同学们在编程网格上编写的程序一样。
但是，为了使程序更加友好和易用，我们可以使用一些图形用户界面（GUI）库来创建一个简单的交互界面，美化我们的程序。

对于感兴趣的同学，可以使用python的`tkinter`库来创建一个简单的图形用户界面，同学可以自行选择其他GUI库来实现。

> 助教小声：这部分代码当然不会查重，不管是用gpt写的还是网上搬得，只要能做出来都OK（GUI罪大滔天）

#### 文件上传和下载（5分）

要实现这个任务，我们需要在客户端和服务器新增一条上传文件/下载文件的功能：

可以使用`open`/`read`/`write`等文件操作函数来实现文件的读写，还要增加客户端向服务器发送文件，服务器接收文件的代码等等。

（跟GUI配合效果更佳）

#### 多线程服务器（5分）

python有一个`threading`库，可以用来实现多线程。

我们需要用到该库的以下方法：
- `threading.Thread(target=func, args=())`：创建一个线程，`target`是线程的执行函数，`args`是传递给函数的参数。
- `thread.start()`：启动线程。
- `thread.join()`：等待线程结束。

在服务器端，我们可以使用多线程来同时处理多个客户端的请求，提高服务器的并发性能。

> tips: 把服务器现有的处理程序重写成一个函数，用于传入target参数；将模板的while循环改为监听多个客户端的连接，然后每个连接开一个线程处理即可。

例如：
```python
# server.py
import threading
def handle_client(sock, addr):
    # 与客户端交互处理客户端请求
    pass

# 假设bind和listen已经完成
while True:
    sock, addr = server.accept()
    thread = threading.Thread(target=handle_client, args=(sock, addr))
    thread.start()
    # TODO


```


#### 隐含语义挖掘（10分）

我们可以简单使用`synonyms`库来获得近义词，然后根据这些近义词来检索文章内容。

也可以使用一些简单自然语言处理的算法来挖掘近义词或是文章的隐含语义，提高搜索的准确性。这里提供两种：

**简单的相似度计算方式：Jarccard相似度**

Jarccard相似度是一种用于计算两个集合相似度的方法，它是两个集合交集元素个数与并集元素个数的比值。

$$
J(A,B) = \frac{|A \cap B|}{|A \cup B|}
$$

我们可以使用Jarccard相似度来计算查询词集合与文章内容词集合的匹配程度，从而提高搜索的准确性。集合计算的代码实现不难，在这里就不给出实现了。

**基于TF-IDF改进的Jaccard相似度**

TF-IDF是一种用于评估文本中词语重要性的方法，它是词频（TF）和逆文档频率（IDF）的乘积。

$$
TF/IDF(t,d) = TF(t,d) \times IDF(t)，\\
其中TF(t,d) = \frac{t在d中出现的次数}{d中所有词的总数}，\\
IDF(t) = \log\frac{N}{t在所有文档中出现的次数}
$$

要获得TF-IDF值，我们可以使用机器学习库`sklearn`中的`TfidfVectorizer`类。

```python
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# 计算两个文本的TF-IDF Jaccard相似度
def tfidf_jaccard_similarity(text1, text2):
    vectorizer = TfidfVectorizer()
    tfidf_matrix = vectorizer.fit_transform([text1, text2])
    cosine_sim = cosine_similarity(tfidf_matrix[0:1], tfidf_matrix[1:2])
    return cosine_sim[0][0]
```



#### 良好的代码风格

“这部分”不会单独计分，但是呢……（助教看到赏心悦目的代码，更快的理解到你的代码逻辑，那些部分的分自然也会给的更高）

> 良好的代码风格包括但不限于：
> - 代码缩进、对齐、空格等格式规范。
> - 代码注释充分，对于一些复杂的逻辑，需要写清楚注释。
> - 代码逻辑清晰，模块化设计，不要将所有代码写在一个文件中。




## 报告撰写

在完成项目之后，同学们需要撰写一份报告，报告内容包括：
- 你完成了哪些加分项？
- 你的基础框架设计，包括客户端和服务器的功能设计。
- 你的网络通信，简单展示你的代码。
- 你的客户端完成了哪些功能，该如何去使用你的客户端。
- 你的服务器完成了哪些功能，该如何去运行你的服务器。
- 关于附加任务，你的设计思路和实现方法。



## 写在最后

助教一不小心洋洋洒洒写了这么多，但尽管本次作业涉及到了很多课外的知识，大部分课外的内容在文档里也已经有了很详细的说明和参考代码了，需要各位完成的主要是课内掌握了的部分。本次作业的难度并不大，只要同学们认真阅读文档，按照文档的要求一步一步来，相信是能够顺利完成的。

尽管这份作业给同学们设置了非常多的加分项，但是我们并不希望同学们为了加分而卷（毕竟基础部分就有90，而加分加到满分为止hh）
我们希望同学们能够在完成基础任务的基础上，能够按照文档的描述，量力而行的尝试一些新的东西，嗯（所以助教肝文档肝到通宵）没有做加分项的同学也不要紧，助教不会因为这一点就给你的基础项打低分的

现在随着各大生成式语言大模型的盛行，相信也会有大量的同学会使用AI来辅助自己这次作业的完成。考虑到AI作为现在编程的有力辅助工具，助教不反对同学们在遇到难题时使用AI来帮助自己的编程，但是AI只是一个工具，它不能取代你的思考，学习（况且考试的时候也不会让你用），所以建议大家一定要冷静，谨慎，克制的使用AI！
